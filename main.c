#include <stdio.h>
#include <stdlib.h>
#include "gamerules.h"
#include "main.h"
#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
#include "images/vcar.h"
#include "images/mcar.h"
#include "images/startScreen.h"
#include "images/winScreen.h"
#include "images/loseScreen.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
int myMcars[4];


int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;
  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  GBAState state = START;
  GBAState lastState = START; // tracking last state

    char scoreStr[] = "SCORE: xxx"; // score display string for each time an enemy car is passed
    u16 score = 0; // score; resets every new game
    u16 fillS = 0; // only first entered for GAME
    const unsigned short *imgPtr = start_screen; // pointer variable for drawing images
    Vcar vcar;
    Mcar mcar1;
    mcar1.row = 15;
    mcar1.cc = 0;
    Mcar mcar2;
    mcar2.row = 62;
    mcar2.cc = 0;
    Mcar mcar3;
    mcar3.row = 100;
    mcar3.cc = 0;
    Mcar mcar4;
    mcar4.row = 135;
    mcar4.cc = 0;
    myMcars[0] = (int) &mcar1;
    myMcars[1] = (int) &mcar2;
    myMcars[2] = (int) &mcar3;
    myMcars[3] = (int) &mcar4;
  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
            state = START;
        }
        
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
            state = GAME;
        }
    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    switch (state) {
      case START:
        reset(&score, &vcar, &mcar1, &mcar2, &mcar3, &mcar4);
          lastState = START;
          imgPtr = start_screen;
          break;
      case GAME:
        if (lastState != GAME) {
          lastState = GAME;
          fillS = 1;
        } else {
          fillS = 0;
          if (vcar.row_last != vcar.row || vcar.col_last != vcar.col) {
            if (countMcars() < 2) {
              int index = score % 4;
              Mcar *mcar = (Mcar*)myMcars[index];
              if (mcar->cc == 0) {
                createMcar(mcar);
              }
            }
          }

          for (int i = 0; i < 4; i++) {
            if (((Mcar*)myMcars[i])->cc == 1) {
              movingMcar(((Mcar*)myMcars[i]), &score);
            }
          }

          switch(collision1(&vcar)) {
            case CONSTANT:
              movingVcar(&vcar, &score);
              break;
            
            case COLLIDED:
              if (score >= 10 ) {
                state = WIN;
                imgPtr = win_screen;
              } else {
                state = LOSE;
                imgPtr = lose_screen;
              }
              break;
          }
        }
        break;
      case WIN:
        reset(&score, &vcar, &mcar1, &mcar2, &mcar3, &mcar4);
        lastState = WIN;
        imgPtr = win_screen;
        break;
      case LOSE:
        reset(&score, &vcar, &mcar1, &mcar2, &mcar3, &mcar4);
        lastState = LOSE;
        imgPtr = lose_screen;
        break;
    }
     waitForVBlank();

    if (state != GAME) {
        drawFullScreenImageDMA(imgPtr);
    } else {
        if (fillS) {fillScreenDMA(WHITE); }
        drawRectDMA(145, 50, 50, 50, WHITE);     // undraw score
        drawRectDMA(mcar1.row, mcar1.col_last, MAELSTROM_CAR_WIDTH, MAELSTROM_CAR_HEIGHT, WHITE);
        drawRectDMA(mcar2.row, mcar2.col_last, MAELSTROM_CAR_WIDTH, MAELSTROM_CAR_HEIGHT, WHITE);
        drawRectDMA(mcar3.row, mcar3.col_last, MAELSTROM_CAR_WIDTH, MAELSTROM_CAR_HEIGHT, WHITE);
        drawRectDMA(mcar4.row, mcar4.col_last, MAELSTROM_CAR_WIDTH, MAELSTROM_CAR_HEIGHT, WHITE);
        if (mcar1.cc == 1) {
        drawImageDMA(mcar1.row, mcar1.col, MAELSTROM_CAR_WIDTH, MAELSTROM_CAR_HEIGHT, maelstrom_car);
        }
        if (mcar2.cc == 1) {
        drawImageDMA(mcar2.row, mcar2.col, MAELSTROM_CAR_WIDTH, MAELSTROM_CAR_HEIGHT, maelstrom_car);
        }
        if (mcar3.cc == 1) {
        drawImageDMA(mcar3.row, mcar3.col, MAELSTROM_CAR_WIDTH, MAELSTROM_CAR_HEIGHT,maelstrom_car);
        }
        if (mcar4.cc == 1) {
        drawImageDMA(mcar4.row, mcar4.col, MAELSTROM_CAR_WIDTH, MAELSTROM_CAR_HEIGHT, maelstrom_car);
        }
        drawRectDMA(vcar.row - 5, vcar.col_last, V_CAR_WIDTH + 2, V_CAR_HEIGHT + 10, WHITE);
        drawImageDMA(vcar.row, vcar.col, V_CAR_WIDTH, V_CAR_HEIGHT, V_car);

        scoreStr[7] = score/100 + 48;
        scoreStr[8] = (score%100)/10 + 48;
        scoreStr[9] = score%10 + 48;      
        drawString(145, 10, scoreStr, BLACK);  // display score

    }
    previousButtons = currentButtons; // Store the current state of the buttons
  }
  return 0;
}

void reset(u16 *score, Vcar *vcar, Mcar *mcar1, Mcar *mcar2, Mcar *mcar3, Mcar *mcar4) {
  *score = 0;
  resetVcar(vcar);
  resetMcar(mcar1, mcar2, mcar3, mcar4);
}

int countMcars(void) {
  int count = 0;
  for (int i = 0; i < 4; i ++) {
    int car = myMcars[i];
    if (((Mcar*)car) -> cc == 1) {
      count++;
    }
  }
  return count;
}